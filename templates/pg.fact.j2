#!/usr/bin/env python2
# vim: syntax=python
"""
Ansible custom facts about a postgres node:
"""
import os
import re
import subprocess
import json
from os import path

class State:
    NOT_REACHABLE = 'NOT_REACHABLE'     # stop the inventory due insufficient data
    CONFIGURED_SLAVE = 'CONFIGURED_SLAVE'  # recovery.conf is present
    CONFIGURED_MASTER = 'CONFIGURED_MASTER' # no recovery.conf but postgresql.conf
    EMPTY_DATA_DIR = 'EMPTY_DATA_DIR'
    DEACTIVATED = 'DEACTIVATED'       # e.g. after rolling upgrade, but the VM not deleted yet
    NOT_INITIALIZED = 'NOT_INITIALIZED'   # postgres is not installed yet
    UNKNOWN = None
    # NOT_REACHABLE = 1     # stop the inventory due insufficient data
    # CONFIGURED_SLAVE = 2  # recovery.conf is present
    # CONFIGURED_MASTER = 3 # no recovery.conf but postgresql.conf
    # EMPTY_DATA_DIR = 4
    # DEACTIVATED = 5       # e.g. after rolling upgrade, but the VM not deleted yet
    # NOT_INITIALIZED = 6   # postgres is not installed yet
    # UNKNOWN = None


def detect_state():
    status = 0
    lsres = ""
    try:
        lsres = subprocess.check_output(['ls', '-1','{{ pg_data_dir }}/data'])
    except subprocess.CalledProcessError as ex:
        status = ex.returncode
        lsres = ex.output
    # print(status, lsres)
    files = [f.strip() for f in lsres.split("\n")]
    # print(files, ('postgresql.conf' in files))
    if 'postgresql.conf.deactivated' in files:
        return State.DEACTIVATED
    elif 'recovery.conf' in files:
        return State.CONFIGURED_SLAVE
    elif 'postgresql.conf' in files:
        return State.CONFIGURED_MASTER
    elif status == 2:
        try:
            lsres = subprocess.check_output(['ls', '-1', '{{ pg_data_dir }}'])
        except subprocess.CalledProcessError as ex:
            status = ex.returncode
            lsres = ex.output
        if status == 2:
            return State.NOT_INITIALIZED
        else:
            return State.EMPTY_DATA_DIR
    elif status == 0:
        return State.EMPTY_DATA_DIR

def get_size(start_path = '.'):
    total_size = 0
    for dirpath, dirnames, filenames in os.walk(start_path):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            total_size += os.path.getsize(fp)
    return total_size

def detect_size_mb(subdir):
    return get_size(path.join('{{ pg_data_dir }}/data', subdir))/1024/1024

def run_sql(statement):
    """Run an SQL statement returning single record and return results as tuple"""
    out = subprocess.check_output("""sudo -iu postgres psql -t -c "{}" ; exit 0 """.format(statement), shell=True)
    return [v.strip() for v in out.split("|")]

def detect_wal_setting():
    return run_sql("""SELECT setting FROM pg_settings WHERE name = 'wal_keep_segments';""")[0]

def check_replication():
    try:
        delay, replay_timestamp, last_xlog, running_recovery = run_sql(
            "select now()-pg_last_xact_replay_timestamp() as delay, pg_last_xact_replay_timestamp(), pg_last_xlog_receive_location(), pg_is_in_recovery();")
        if delay == '':
            delay = "lost track?"
        if running_recovery == 't':
            running = "slave/recovery"
        elif running_recovery == 'f':
            running = "master"
            delay = "master"
            last_xlog = run_sql("select pg_current_xlog_location();")[0]
        else:
            running = "unknown"
        return (running, last_xlog, delay)
    except:
        return ("not-running", "error", "error")

if __name__ == '__main__':
    from sys import argv
    if (len(argv) > 1) and ('-s' in argv[1]):
        print detect_state()
    else:
        running, last_xlog, repl_delay = check_replication()
        print json.dumps({
            "state": "{0}".format(detect_state()),
            "mb_db": detect_size_mb("base"),
            "mb_xlog": detect_size_mb("pg_xlog"),
            "wal_keep": detect_wal_setting(),
            "running": running,
            "last_xlog": last_xlog,
            "repl_delay": repl_delay,
            })
